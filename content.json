{"pages":[{"title":"","text":"layout: tags","link":"/tags/index.html"},{"title":"关于我","text":"基本信息 生辰：农历甲戌年冬月十七卯时 出生地：江淮官话洪巢片区 爱好 读书我看书的起步阶段比较晚，从本科开始才有阅读的习惯，初期小说类文学作品居多。曾经看过一部两千多章的网络小说，内容冗长重复，至今引以为耻。在硕士阶段开始涉猎科普、心理学、纪实文学方面的图书。涉猎越多，觉得自己知道的越少，变得越来越不敢随意评价自己不了解的领域，也同时变得不喜欢与人争论。 素描画我觉得这更像是消磨时间的一种方式，毕竟只是高兴了想起来便画一画，素材一般取自动漫里的场景。我没有系统的学过，只是照猫画虎。可能用不着科班出生的人，绘画业余爱好者都能看出其中的大问题。 走路我去过的地方不多，现在明显感觉时间变少了，希望以后能有时间继续走走 对未来的期望 有一个属于自己的房子，面朝地铁，春暖花开 同我中意的女子结婚生子 能够享受到人生的乐趣","link":"/about/index.html"},{"title":"","text":"layout: categories","link":"/categories/index.html"}],"posts":[{"title":"Vue生命周期","text":"简介定义：每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等，不同的时期对应不同的周期； 生命周期函数：不同周期开放出来的接口； Vue的生命周期函数主要包括以下几个: beforeCreate 、created beforeMount 、mounted beforeUpdate、 updated beforeDestroy、destroyed 流程解读第一步：初始化事件和生命周期。此时\\$data、\\$el和message均处于undefined状态。（前缀 $，以便与用户定义的属性区分开来）。 beforeCreate：此时组件实例未创建，各个属性均没有生成。 第二步：Init、injections、 reactivity。属性均已注入绑定，而且被$watch变成reactivity。但是$el还是没有生成，也就是DOM没有生成； created：\\$data和message均已存在，\\$el还没有。 第三步：判断vue实例中是否有\\$el。如果有，则判断是否有template。如果没有则在手动挂载\\$el之后，再判断是否有template。 第四步： 1、在实例内部有template属性的时候，直接用内部的，然后调用render函数去渲染。 2、在实例内部没有找到template，就调用外部的html。实例内部的template属性比外部的优先级高。 3、要是前两者都不满足，那么就抛出错误。 beforeMount：只编译了模板，并没有挂载属性。即此时存在的还是虚拟DOM 第五步：创建vm.$el替换虚拟DOM（vm为初始化的实例对象）。 mounted：此时属性已挂载。\\$data、\\$el和message均处于已定义的状态。 beforeUpdate和updated：当数据改变时，这两个生命周期函数控制view层重新渲染。 渲染步骤：数据改变——导致虚拟DOM的改变——调用这两个生命钩子去改变视图 1、只有当数据与模板中的数据绑定才会这两个函数才会有效； 123456789101112131415var vm = new Vue({ el: '#app', template: '&lt;div id=\"app\"&gt;&lt;/div&gt;', // 这里需要是&lt;div id=\"app\"&gt;{{a}}&lt;/div&gt;才有效果 beforeUpdate: function() { console.log('调用了beforeUpdate') }, updated: function() { console.log('调用了uodated') }, data: { a: 1 }})vm.a = 2 // 虽然数据发生了改变，但是并未与模板绑定，所以控制台不会打印任何一条语句 2、数据改变后，在beforeUpdate和updated中分别console.log(this.$el)发现输出结果相同 beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 this.$el是一个对象，或者说是一个指针。所以更新之后显示的都是一样的。可以通过 1console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) 观察真实的DOM结构比对。实际中可以发现beforeUpdate中还是原来的数据，updated变成了之后的数据。 beforeDestory和destoryed：1、使用app.$destroy()进行销毁； 销毁后DOM元素仍然存在，但是再次改变data的值，beforeUpdate和updated均不起作用。即Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 生命周期函数的使用场景： beforeCreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容 示例代码：（监测\\$el、\\$data、\\$message变化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue生命周期学习&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Vue的生命周期' }, // 模板将会 替换 挂载的元素 beforeCreate: function() { console.group('------beforeCreate创建前状态------'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) }, created: function() { console.group('------created创建完毕状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeMount: function() { console.group('------beforeMount挂载前状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, mounted: function() { console.group('------mounted 挂载结束状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) } })&lt;/script&gt;&lt;/html&gt; 参考文献 详解vue生命周期 - SegmentFault思否 API - Vue.js vue生命周期详解 - 掘金 vue2 为什么beforeUpdate时的$el 和$data与updated时的一样","link":"/2018/09/10/Vue 生命周期/"},{"title":"二分查找算法","text":"不同场景下二分查找算法的使用~~Cpp版本 1.1 基本的二分搜索(递归)1234567891011121314// 普通二分：递归int BSearch1(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; if (left &gt; right) { return -1; } int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { return BSearch1(ve, target); } else if (ve[mid] &lt; target) { return BSearch1(ve, target); } return ve[mid];} 1.2 基本的二分搜索（循环）1234567891011121314// 普通二分：循环int BSearch2(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { right = mid - 1; } else if (ve[mid] &lt; target) { left = mid + 1; } else { return ve[mid]; } }} 2.1 查找第一个与target相等的元素的索引123456789101112int BSearch3(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt;= target) { right = mid - 1; } else { left = mid + 1; } } return ve[left] == target ? left : -1;} 2.2 查找最后一个与target相等的元素的索引123456789101112int BSearch4(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt;= target) { left = mid + 1; } else { right = mid - 1; } } return ve[right] == target ? right : -1;} 2.3 查找最后一个小于target的元素索引123456789101112int BSearch5(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return right;} 2.4 查找第一个大于target的元素索引123456789101112int BSearch6(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { right = mid - 1; } else { left = mid + 1; } } return left;} 2.5 查找最后一个小于等于target的元素的索引123456789101112int BSearch7(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt;= target) { left = mid + 1; } else { right = mid - 1; } } return right;} 2.6 查找第一个大于等于target的元素的索引123456789101112int BSearch8(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt;= target) { right = mid - 1; } else { left = mid + 1; } } return left;} 2.7 查找target所处范围123456789// 查找target所处范围，没有返回-1vector&lt;int&gt; BSearch9(vector&lt;int&gt; vex, int target) { vector&lt;int&gt; res; int leftIndex = BSearch3(vex, target); int rightIndex = BSearch4(vex, target); res.push_back(leftIndex &lt; 0 ? -1 : leftIndex); res.push_back(rightIndex &lt; 0 ? -1 : rightIndex); return res;}","link":"/2018/10/20/二分搜索算法/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/数据结构与算法/"},{"name":"基础原理类","slug":"Vue/基础原理类","link":"/categories/Vue/基础原理类/"},{"name":"二分查找","slug":"数据结构与算法/二分查找","link":"/categories/数据结构与算法/二分查找/"}]}