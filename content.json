{"pages":[{"title":"关于我","text":"基本信息 生辰：农历甲戌年冬月十七卯时 出生地：江淮官话洪巢片区 爱好 读书我看书的起步阶段比较晚，从本科开始才有阅读的习惯，初期小说类文学作品居多。曾经看过一部两千多章的网络小说，内容冗长重复，至今引以为耻。在硕士阶段开始涉猎科普、心理学、纪实文学方面的图书。涉猎越多，觉得自己知道的越少，变得越来越不敢随意评价自己不了解的领域，也同时变得不喜欢与人争论。 素描画 我觉得这更像是消磨时间的一种方式，毕竟只是高兴了想起来便画一画，素材一般取自动漫里的场景。我没有系统的学过，只是照猫画虎。可能用不着科班出生的人，绘画业余爱好者都能看出其中的大问题。 走路我去过的地方不多，现在明显感觉时间变少了，希望以后能有时间继续走走。足迹图使用谷歌地图，可能会导致你看到的下方是一片空白 对未来的期望 有一个属于自己的房子，面朝地铁，春暖花开 同我自己中意的女子结婚生子 能够享受到人生的乐趣","link":"/about/index.html"},{"title":"","text":"layout: categories","link":"/categories/index.html"},{"title":"","text":"layout: tags","link":"/tags/index.html"}],"posts":[{"title":"Vue生命周期","text":"简介定义：每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等，不同的时期对应不同的周期； 生命周期函数：不同周期开放出来的接口； Vue的生命周期函数主要包括以下几个: beforeCreate 、created beforeMount 、mounted beforeUpdate、 updated beforeDestroy、destroyed 流程解读第一步：初始化事件和生命周期。此时\\$data、\\$el和message均处于undefined状态。（前缀 $，以便与用户定义的属性区分开来）。 beforeCreate：此时组件实例未创建，各个属性均没有生成。 第二步：Init、injections、 reactivity。属性均已注入绑定，而且被$watch变成reactivity。但是$el还是没有生成，也就是DOM没有生成； created：\\$data和message均已存在，\\$el还没有。 第三步：判断vue实例中是否有\\$el。如果有，则判断是否有template。如果没有则在手动挂载\\$el之后，再判断是否有template。 第四步： 1、在实例内部有template属性的时候，直接用内部的，然后调用render函数去渲染。 2、在实例内部没有找到template，就调用外部的html。实例内部的template属性比外部的优先级高。 3、要是前两者都不满足，那么就抛出错误。 beforeMount：只编译了模板，并没有挂载属性。即此时存在的还是虚拟DOM 第五步：创建vm.$el替换虚拟DOM（vm为初始化的实例对象）。 mounted：此时属性已挂载。\\$data、\\$el和message均处于已定义的状态。 beforeUpdate和updated：当数据改变时，这两个生命周期函数控制view层重新渲染。 渲染步骤：数据改变——导致虚拟DOM的改变——调用这两个生命钩子去改变视图 1、只有当数据与模板中的数据绑定才会这两个函数才会有效； 123456789101112131415var vm = new Vue({ el: '#app', template: '&lt;div id=\"app\"&gt;&lt;/div&gt;', // 这里需要是&lt;div id=\"app\"&gt;{{a}}&lt;/div&gt;才有效果 beforeUpdate: function() { console.log('调用了beforeUpdate') }, updated: function() { console.log('调用了uodated') }, data: { a: 1 }})vm.a = 2 // 虽然数据发生了改变，但是并未与模板绑定，所以控制台不会打印任何一条语句 2、数据改变后，在beforeUpdate和updated中分别console.log(this.$el)发现输出结果相同 beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 this.$el是一个对象，或者说是一个指针。所以更新之后显示的都是一样的。可以通过 1console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) 观察真实的DOM结构比对。实际中可以发现beforeUpdate中还是原来的数据，updated变成了之后的数据。 beforeDestory和destoryed：1、使用app.$destroy()进行销毁； 销毁后DOM元素仍然存在，但是再次改变data的值，beforeUpdate和updated均不起作用。即Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 生命周期函数的使用场景： beforeCreate : 举个栗子：可以在这加个loading事件 created ：在这结束loading，还做一些初始化，实现函数自执行 mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容 示例代码：（监测\\$el、\\$data、\\$message变化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;vue生命周期学习&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { message: 'Vue的生命周期' }, // 模板将会 替换 挂载的元素 beforeCreate: function() { console.group('------beforeCreate创建前状态------'); console.log(\"%c%s\", \"color:red\" , \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) }, created: function() { console.group('------created创建完毕状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeMount: function() { console.group('------beforeMount挂载前状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, mounted: function() { console.group('------mounted 挂载结束状态------'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); //已被初始化 }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log(\"真实的DOM结构: \"+ document.getElementById('app').innerHTML) console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\",\"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\",\"data : \" + this.$data); console.log(\"%c%s\", \"color:red\",\"message: \" + this.message) } })&lt;/script&gt;&lt;/html&gt; 参考文献 详解vue生命周期 - SegmentFault思否 API - Vue.js vue生命周期详解 - 掘金 vue2 为什么beforeUpdate时的$el 和$data与updated时的一样","link":"/2018/09/10/Vue 生命周期/"},{"title":"静态资源加速","text":"网站的静态资源介绍在使用浏览器控制台观测各个网站的详细信息时，可以看到head标签中存在大量引用的js、css或其它类型的文件。如下所示：1234&lt;!--指向站点内部的文件--&gt;&lt;meta content=\"/images/branding/googleg/1x/googleg_standard_color_128dp.png\" itemprop=\"image\"&gt;&lt;!--绝对路径指向外部站点的js--&gt;&lt;script src=\"http://apps.bdimg.com/libs/bootstrap/3.3.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; 如果网站规模较小、资源请求数少、对存储空间、并发量的要求不高，可以尝试将资源代码与业务代码存放在一起的方式。如果网站规模扩大，优化的方式也有许多，单从静态资源的角度看可以将资源服务器与业务服务器分离。这就引入了CDN的概念 CDN（Content Delivery Network）CDN即内容分发网络。通俗意义上说就是能够让你访问网站的速度变快。可以将资源类型的文件存储在CDN服务器中，CDN系统根据当前互联网运行的各项指标如节点的连接、负载、到用户的响应时间和距离，将请求导向离用户最近的服务节点上。这样既保证了访问的稳定性与速度也降低了业务服务器的资源流量。国内做CDN的厂商有阿里云、百度、七牛、又拍等。阿里云的售后保障是比较靠谱的，当然价格也相对较高，其他公司的产品没用过，不做评价。其中有一家叫白山云的公司，产品好不好不知道，但面试体验是极好的。（可惜没有谁给我广告费） 图片资源的处理静态站点中如果存在的大量图片，那么图片请求时间过长会导致站点的访问速度变慢。提高网站的图片加载速度当然也可以使用CDN，同时也可以对图片本身进行压缩合并。这里提供一种思路：本站的原始背景图片是大小为4M左右格式为png的图片。经压缩后大小为1M左右，格式仍为png，肉眼看不出变化，压缩率达到75%左右。压缩站点TinyPNG。但是实测中访问速度不是很明显。所以再次将图片压缩为webP格式，肉眼仍看不出变化，压缩度达到90%左右。压缩站点Squoosh。但是该图片格式由谷歌推出，Chrome与Opera能够实现支持，FireFox暂不可以（据说可能需要到明年上半年）。所以使用Firefox等浏览器访问得到的是#e7e7e7为背景色的网站。 参考文献 CDN是什么？使用CDN有什么优势？ - 知乎 WebP 相对于 PNG、JPG 有什么优势？- 知乎 网站加载图片速度慢如何优化 - SegmentFault 思否 webP - 维基百科","link":"/2018/11/17/静态资源加速/"},{"title":"二分搜索算法","text":"1.1 基本的二分搜索(递归)1234567891011121314// 普通二分：递归int BSearch1(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; if (left &gt; right) { return -1; } int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { return BSearch1(ve, target); } else if (ve[mid] &lt; target) { return BSearch1(ve, target); } return ve[mid];} 1.2 基本的二分搜索（循环）1234567891011121314// 普通二分：循环int BSearch2(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { right = mid - 1; } else if (ve[mid] &lt; target) { left = mid + 1; } else { return ve[mid]; } }} 2.1 查找第一个与target相等的元素的索引123456789101112int BSearch3(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt;= target) { right = mid - 1; } else { left = mid + 1; } } return ve[left] == target ? left : -1;} 2.2 查找最后一个与target相等的元素的索引123456789101112int BSearch4(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt;= target) { left = mid + 1; } else { right = mid - 1; } } return ve[right] == target ? right : -1;} 2.3 查找最后一个小于target的元素索引123456789101112int BSearch5(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return right;} 2.4 查找第一个大于target的元素索引123456789101112int BSearch6(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt; target) { right = mid - 1; } else { left = mid + 1; } } return left;} 2.5 查找最后一个小于等于target的元素的索引123456789101112int BSearch7(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &lt;= target) { left = mid + 1; } else { right = mid - 1; } } return right;} 2.6 查找第一个大于等于target的元素的索引123456789101112int BSearch8(vector&lt;int&gt; ve, int target) { int left = 0, right = ve.size()-1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (ve[mid] &gt;= target) { right = mid - 1; } else { left = mid + 1; } } return left;} 2.7 查找target所处范围123456789// 查找target所处范围，没有返回-1vector&lt;int&gt; BSearch9(vector&lt;int&gt; vex, int target) { vector&lt;int&gt; res; int leftIndex = BSearch3(vex, target); int rightIndex = BSearch4(vex, target); res.push_back(leftIndex &lt; 0 ? -1 : leftIndex); res.push_back(rightIndex &lt; 0 ? -1 : rightIndex); return res;}","link":"/2018/10/20/二分搜索算法/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"图片压缩","slug":"图片压缩","link":"/tags/图片压缩/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"建站实录","slug":"建站实录","link":"/categories/建站实录/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/数据结构与算法/"},{"name":"基础原理类","slug":"Vue/基础原理类","link":"/categories/Vue/基础原理类/"},{"name":"静态资源加速","slug":"建站实录/静态资源加速","link":"/categories/建站实录/静态资源加速/"},{"name":"二分查找","slug":"数据结构与算法/二分查找","link":"/categories/数据结构与算法/二分查找/"}]}